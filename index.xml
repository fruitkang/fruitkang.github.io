<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>果汁康</title>
    <link>https://fruitkang.github.io/</link>
    <description>Recent content on 果汁康</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 20 Jun 2023 22:12:50 +0800</lastBuildDate>
    
	<atom:link href="https://fruitkang.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go书籍推荐</title>
      <link>https://fruitkang.github.io/books/go%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/books/go%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</guid>
      <description> 0、简介   深入理解Linux网络 网络是怎样连接的   1、个人声明 这里推荐的书籍本人都进行过阅读，一家之言，如有冒犯，概不负责2、推荐 2.1、Go专家编程  学习Go基础可以看此书，对一些概念解释的挺清晰，例如比较核心的协程哪一块
 2.2、Go Web编程  Go语言Web网站搭建可以看此书，介绍了web开发中常用技术的Go方法，例如socket，以及框架Beego和Gorm
 </description>
    </item>
    
    <item>
      <title>Java BIO&amp;NIO&amp;AIO</title>
      <link>https://fruitkang.github.io/java/java-bionioaio/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/java/java-bionioaio/</guid>
      <description>1、简介 本节主要介绍Java的IO模型。
 BIO：阻塞式IO模型
 NIO：非阻塞式IO模型
 AIO：异步非阻塞网络通信模型
  2、BIO阻塞式IO模型 BIO在连接的建立与读数据都是阻塞式的。
在BIO模型所有的客户端与服务器的IO操作是直接通过socket操作的。
package com.gzk.bio; import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; /** * @author 23A2 * @date 2021-11-02 * @deprecated socket服务端 */ public class SocketServer { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(9000); while (true){ /*此方法为阻塞的*/ Socket socket = serverSocket.accept(); System.out.println(&amp;quot;客户端连接了&amp;quot;); new Runnable(){ @Override public void run() { try { /*有客户端连接，则处理客户端连接*/ handler(socket); } catch (IOException e) { e.</description>
    </item>
    
    <item>
      <title>Java书籍推荐</title>
      <link>https://fruitkang.github.io/books/java%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/books/java%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</guid>
      <description> 0、简介   深入理解Java虚拟机 Java编程思想   1、个人声明 这里推荐的书籍本人都进行过阅读，一家之言，如有冒犯，概不负责2、推荐  没有理由，经典必读
没有理由，经典必读
 </description>
    </item>
    
    <item>
      <title>Java基础概述</title>
      <link>https://fruitkang.github.io/java/java%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/java/java%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java基础语法</title>
      <link>https://fruitkang.github.io/java/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/java/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java多线程</title>
      <link>https://fruitkang.github.io/java/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/java/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java异常处理</title>
      <link>https://fruitkang.github.io/java/java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/java/java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java数组</title>
      <link>https://fruitkang.github.io/java/java%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/java/java%E6%95%B0%E7%BB%84/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java面向对象编程</title>
      <link>https://fruitkang.github.io/java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Java面向对象编程（下）</title>
      <link>https://fruitkang.github.io/java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%8B/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E4%B8%8B/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Linux修改主机名</title>
      <link>https://fruitkang.github.io/linux/linux%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/linux/linux%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D/</guid>
      <description>一、简介  CentOS有三类的主机名
静态的（static hotsname）也称内核主机名，是系统在启动时从/etc/hostname初始化的主机名。
瞬态/动态的（transient hostname） 是系统运行时临时分配的主机名。例如，通过DHCP或者mDNS服务器分配。
灵活的（pretty hostname）也称”别名“主机名，允许使用特殊符号或者空格。静态和瞬态主机名需要遵从互联网域名同样的规则。
 1.1、查看主机名称  CentOS中提供了hostnamectl命令
[root@node01 ~]# hostnamectl Static hostname: node01 Icon name: computer-vm Chassis: vm Machine ID: 5f9b4f4a14b24bb5b4c26f67f59d06fd Boot ID: 62e9c57cf06e4665a4c3b41761da6f05 Virtualization: vmware Operating System: CentOS Linux 7 (Core) CPE OS Name: cpe:/o:centos:centos:7 Kernel: Linux 3.10.0-1160.el7.x86_64 Architecture: x86-64 # 查看静态主机名 [root@node01 ~]# hostnamectl --static node01 # 查看瞬态主机名 [root@node01 ~]# hostnamectl --transient node01 # 查看灵活主机名 [root@node01 ~]# hostnamectl --pretty  CentOS中其他查看主机名命令</description>
    </item>
    
    <item>
      <title>Linux安装mysql5.7</title>
      <link>https://fruitkang.github.io/linux/linux%E5%AE%89%E8%A3%85mysql5.7/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/linux/linux%E5%AE%89%E8%A3%85mysql5.7/</guid>
      <description>①下载并mysql官方提供的yum仓库。
文件下载路径：
http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm
文件：
#下载文件 wget -i http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm #安装该yum仓库源 yum install mysql57-community-release-el7-10.noarch.rpm  安装完该yum仓库我可以发现在centos的仓库文件下多了两个文件。
②安装mysql服务
#执行安装命令-指定了安装路径 yum --installroot=/opt/mysql57 --releasever=/ install mysql-community-server #安装命令 yum install mysql-community-server  安装中途选择输入都为：y
等待安装程序输出&amp;rdquo;完毕&amp;rdquo;则安装完成。
这种安装方式会自动覆盖centos自带的mariadb。
③启动mysql服务
#启动mysql服务 systemctl start mysqld #查看mysql服务的状态 systemctl status mysqld.service  ④登录mysql
此时mysql服务已经启动，但是要想登录mysql服务必须知道root用户的密码，可以通过查看日志知道root用户的初始密码。
#进入日志目录 cd /var/log #根据password关键字过滤查找初始化密码 grep &amp;quot;password&amp;quot; mysqld.log  登录mysql服务
#登录命令 mysql -uroot -p #输入初始化密码  进行修改密码：新密码必须包含数字大小写字母和符号
ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;new password&#39;;  ⑤开启mysql的远程访问权限
#开启mysql远程访问权限--这里只是开启了192.168.0.1的权限 grant all privileges on *.</description>
    </item>
    
    <item>
      <title>Linux常用操作</title>
      <link>https://fruitkang.github.io/linux/linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/linux/linux%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description>一、设置Linux网络 ①设置Linux的IP地址为静态获取（防止每次重启Linux导致IP地址发生变化）
修改文件 [/etc/sysconfig/network-scripts/ifcfg-enp0s3]
TYPE=&amp;quot;Ethernet&amp;quot; PROXY_METHOD=&amp;quot;none&amp;quot; BROWSER_ONLY=&amp;quot;no&amp;quot; # 设置静态获取ip，若是动态则设置为dhcp BOOTPROTO=&amp;quot; &amp;quot; DEFROUTE=&amp;quot;yes&amp;quot; IPV4_FAILURE_FATAL=&amp;quot;no&amp;quot; IPV6INIT=&amp;quot;yes&amp;quot; IPV6_AUTOCONF=&amp;quot;yes&amp;quot; IPV6_DEFROUTE=&amp;quot;yes&amp;quot; IPV6_FAILURE_FATAL=&amp;quot;no&amp;quot; IPV6_ADDR_GEN_MODE=&amp;quot;stable-privacy&amp;quot; # 设置网卡名称 NAME=&amp;quot;enp0s3&amp;quot; UUID=&amp;quot;6c58d8b7-5780-4c55-8d54-99dc3786d056&amp;quot; DEVICE=&amp;quot;enp0s3&amp;quot; # 设置为yes ONBOOT=&amp;quot;yes&amp;quot; # 设置ip地址 IPADDR=&amp;quot;192.168.1.12&amp;quot; # 设置子网掩码 PREFIX=&amp;quot;24&amp;quot; # 设置网关 GATEWAY=&amp;quot;192.168.1.1&amp;quot; IPV6_PRIVACY=&amp;quot;no&amp;quot;  二、关闭Linux防火墙 查看防火墙状态：systemctl status firewalld
临时关闭防护墙：systemctl stop firewalld（关机重启之后，设置失效）
开启防火墙：systemctl start firewalld（关机重启之后，设置失效）
启用防火墙：systemctl enable firewalld
禁用防火墙：systemctl disable firewalld
三、设置系统DNS服务器 修改文件[/etc/resolv.conf ]，添加DNS服务器地址
nameserver 8.8.8.8 nameserver 114.114.114.114  四、解决yum下载速度慢 yum默认是国外源。所以下载速度慢，所以我们需要更换yum仓库源为阿里或网易等国内源，步骤：
①下载阿里或网易的centos仓库文件。
②使用国内软件仓库文件替换默认国外仓库文件。
#centos软件仓库源文件的存储位置：/etc/yum.repos.d) #进入文件位置 cd /etc/yum.repos.d #创建备份目录 mkdir yum.</description>
    </item>
    
    <item>
      <title>MySQL中select * 的坏处</title>
      <link>https://fruitkang.github.io/mysql/mysql%E4%B8%ADselect-_-%E7%9A%84%E5%9D%8F%E5%A4%84/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/mysql/mysql%E4%B8%ADselect-_-%E7%9A%84%E5%9D%8F%E5%A4%84/</guid>
      <description> 多余的字段会造成解析开销和网络带宽开销，所以一般我们只按需查找数据。 可能用不到覆盖索引，用到也需要回表查询，导致查询速率降低。  </description>
    </item>
    
    <item>
      <title>MySQL书籍推荐</title>
      <link>https://fruitkang.github.io/books/mysql%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/books/mysql%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</guid>
      <description> 0、简介   MySQL技术内幕 MySQL是怎样运行的 高性能MySQL   1、个人声明 这里推荐的书籍本人都进行过阅读，一家之言，如有冒犯，概不负责2、推荐 2.1、MySQL技术内幕   本书主要从基础知识点的方面介绍MySQL知识。主要包括日志文件、行记录格式、索引、算法、索引、事务、锁、MVCC等基础知识。文章讲述较为通俗易懂。
  2.2、MySQL是怎样运行的   本书讲述内容与《MySQL技术内幕》差不多，但叙述的风格是不同的，而且本书最后添加了关于面试中的一些问题也是值得一看的。
 新增面试章节
 2.3、高性能MySQL   本书与上面两本书不同，这本书从更高的角度介绍了mysql，主要包括Mysql架构、Mysql服务优化、创建高性能索引的方式、优化查询性能、Mysql主从复制、Mysql备份与恢复。
通过这本书可以帮我们更高层度的了解Mysql
  </description>
    </item>
    
    <item>
      <title>MySQL体系结构与存储引擎</title>
      <link>https://fruitkang.github.io/mysql/mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/mysql/mysql%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <description> 1、通过执行以下命令可知mysql配置文件位置 mysql --help | grep my.cnf  如果存在多个配置文件有同一个参数，以最后一个配置文件为准。
2、mysql体系结构 1、数据库连接池：用于管理客户端的连接 2、SQL接口组件：提供了客户端SQL语句的规范，例如DML、DDL操作SQL。 3、SQL查询分析器：根据SQL规范解析sql。 4、SQL优化器：对SQL进行优化，使得sql的执行效率更高。 5、缓存组件：对sql语句和查询结果进行缓存，当sql语句一样的时候，就不用进行sql解析和优化了。 6、插件式存储引擎：规定数据存储时的结构，二这种结构也将会影响数据的存储和查询性能。 7、操作系统，物理文件：文件系统，存储了mysql运行中产生的日志，已经MySQL中存储的数据、结构。
3、MySQL存储引擎 3.1、InnoDB存储引擎  支持事务 支持行锁、表锁、页锁 使用多版本控制（MVCC）获得高并发 支持外键 实现数据的4种隔离级别，默认为可重复读（repeatable） 插入缓存区 二次写 自适应哈希索引 预读 inndb1.2之后开始支持全文索引
3.2、MyISAM存储引擎 不支持事务
 表锁
 支持全文索引
 缓存池只缓存索引文件，不缓存数据。数据文件的缓存交由操作系统本身来完成。
3.2、Memory存储引擎 数据放在内存中
 只支持表锁
 不支持TEXT和BLOB类型
4、连接MySQL 1、TCP\IP连接 2、共享内存 3、命名通道 4、UNIX域套接字
  </description>
    </item>
    
    <item>
      <title>MySQL常见问题解决</title>
      <link>https://fruitkang.github.io/mysql/mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/mysql/mysql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</guid>
      <description>1、mysql跳过域名解析（可解决mysql连接慢的问题） 在配置文件中加入如下，并重启 mysql
[mysqld] skip-name-resolve  解释：
skip-name-resolve：跳过域名解析
2、常用配置 [client] default-character-set=utf8 [mysql] default-character-set=utf8 [mysqld] init_connect=&#39;SET collation_connection = utf8_unicode_ci&#39; init_connect=&#39;SET NAMES utf8&#39; character-set-server=utf8 collation-server=utf8_unicode_ci skip-character-set-client-handshake skip-name-resolve  3、mysql开启root用户远程访问 #执行sql语句（两条） grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;root&#39; with grant option; flush privileges;  4、Mysql的通信方式 4.1、TCP/IP网络通信 通过-h指定mysql服务的ip地址，通过-P指定mysql服务监听的端口
win和linux都可以
例如：
#服务端启动 mysqld -P3307 --user=root #客户端启动 mysql -P3307 -uroot -p  4.2、命名管道通信 通过参数使mysql服务器和客户端同时使用命名管道通信。
只适用于win系统
#服务端启动 mysqld --enable-named-pipe #客户端启动 mysql --pipe -uroot -p  4.</description>
    </item>
    
    <item>
      <title>MySQL文件</title>
      <link>https://fruitkang.github.io/mysql/%E6%96%87%E4%BB%B6/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/mysql/%E6%96%87%E4%BB%B6/</guid>
      <description>1、简介    文件 作用     参数文件 告诉mysql启动时去哪里找数据库文件，并指定某些初始化参数   日志文件 记录mysql实例对某种条件做出响应时写入的文件   socket文件 当用unix域套接字方式进行连接时需要的文件   pid文件 mysql实例进程的ID文件   mysql表结构文件 用来存放mysql表结构定义文件   存储引擎文件 存储记录和索引的数据    2、参数为文件 参数文件位置：通过运行mysql --help | grep my.cnf命令即可。 参数类型：
 动态参数：可以在mysql实例运行中进行修改 静态参数：在整个实例生命周期内都不能修改  还可以按照其他角度分类：
 全局 session
3、日志文件 日志文件用来记录影响Mysql数据库的各类型活动。常见日志有：
   错误日志（error log） 二进制日志（binlog） 慢查询日志（slow query log） 查询日志（log）
3.1、错误日志 通过show variables like &#39;log_error&#39;;错误日志文件位置。
   3.</description>
    </item>
    
    <item>
      <title>MySQL索引与算法</title>
      <link>https://fruitkang.github.io/mysql/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/mysql/%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%AE%97%E6%B3%95/</guid>
      <description> 1、Innodb存储引擎常见索引概述 常见索引：
 B+树索引 全文索引 哈希索引  Innodb存储引擎支持的哈希索引是自适应的，Innodb存储引擎会根据表的使用情况自动生成哈希索引，不能人为的干预是否在一张表中生产哈希索引。
2、数据结构与索引 2.1、二分查找法 每页Page Directctory中的槽是按照主键的顺序存放的，对于某一条具体的记录的查询是通过对Page Directory进行二分查找得到的。
2.2、二叉查找树和平衡二叉树 2.2.1、二叉查找树 在二叉树中左子树的键值总是小于根的键值，右子树的键值总是大于根的键值，因此通过中序遍历得到的排序输出。 二叉树的缺点： 2.2.2、平衡二叉树 平衡二叉树必须先符合二叉树的定义，其次必须满足任何节点的两个子树的高度最大差为1。 由二叉树变为平衡二叉树通常需要一次或多次的左旋和右旋来得到插入或更新后树的平衡性。 二叉树的缺点：由于一棵平衡二叉树插入一个新的节点，平衡二叉树需要旋转操作，因此对一棵平衡二叉树的维护有一定的开销。不过平衡二叉树多用于内存结构，因此维护成本开销相对较小。
2.3、B+树 简单定义：B+树为磁盘或其他直接存取辅助设计的一种平衡查找树。
2.3.1、B+树的插入操作 B+树无论如何总是会保持平衡。但是为了保持平衡对于新插入的键值可能需要大量拆分也操作。因为B+树结构主要用于磁盘，页的拆分意味着磁盘的操作，所以应该在可能的情况下减少页的拆分。因此，B+树同样提供了类似的平衡二叉树的旋转功能。通过旋转能够减少页的拆分操作。
2.3.2、B+树的删除操作 B+树使用填充因子来控制树的删除变化。
2.4、B+树索引 B+树索引在数据库中的一个特点为高扇出性，因此B+树的高度一般都在2~4层。
2.4.1、聚集索引 根据主键构造一棵B+树。 数据页叶子节点存放的即为表的行记录数据。 非数据的索引页中存放的仅仅是键值已经指向数据页的偏移量。
2.4.2、非聚集索引（辅助索引） 叶子节点除了保存辅助索引值外还保存了主键，
2.4.3、B+树索引的分裂 2.4.4、B+树索引的管理 </description>
    </item>
    
    <item>
      <title>MySQL自增主键用完之后怎么办？</title>
      <link>https://fruitkang.github.io/mysql/mysql%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%94%A8%E5%AE%8C%E4%B9%8B%E5%90%8E%E6%80%8E%E4%B9%88%E5%8A%9E/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/mysql/mysql%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE%E7%94%A8%E5%AE%8C%E4%B9%8B%E5%90%8E%E6%80%8E%E4%B9%88%E5%8A%9E/</guid>
      <description> 1、简介  Mysql自增主键分为两种，一种为我们主动设置的自增主键。另一种为我们没有设置主键，mysql自动会给我设置一个6个字节的row_id字段为默认自增主键列。
 2、设置自增主键  这种情况下，当mysql的自增主键用完之后将会报主键冲突异常。例如我们有一个无符号的tinyint类型的id主键，他的最大值为255，当主键的值超过255的时候，主键的值就又从0开始了，这时候忧郁主键为0的记录已存在，则会发生主键冲突异常。
 3、不设置默认主键  这时候mysql会为我们添加一个6个字节的row_id字段为默认主键，当这个主键的最大值大于2的48次方之后，也会从0开始，这时候不会报异常，而是会将之前为0主键的记录覆盖掉，覆盖数据是一个重要的问题。
 </description>
    </item>
    
    <item>
      <title>MySQL表</title>
      <link>https://fruitkang.github.io/mysql/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/mysql/innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</guid>
      <description>1、简介 第一个支持ACID事务的存储引擎，行锁设计、支持MVCC、支持外键、提供一致性非锁定读，同时被设计用来最有效的利用内存和CPU。
2、InnoDB存储引擎体系结构 后台线程的作用： ①：刷新内存池中的数据，保存缓存池中内存缓存的时最近的数据。 ②：将已修改的数据文件刷新到磁盘文件 ③：保证数据发生异常异常的情况下能恢复到正常运行状态
2.1、后台线程 InnoDB属于多线程模型。
   线程 作用     Master Thread 将缓存池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓冲、undo页的回收。   IO Thread 负责IO请求的回调   Purge Thread 事务提交之后，其所有使用的undo log可能不在需要，因此需要Purge Thread来回收已经使用并分配的undo页。   Page Cleaner Thread 为了减轻Master Thread的工作对于用户查询线程的阻塞，进一步提高InnoDB存储引擎的性能，InnoDB1.2x版本加入该线程，其作用是接手之前由Master Thread的刷新脏页的工作，减少Master的工作量。    2.2、内存 1、缓存池 InnoDB存储引擎是基于磁盘存储的，并将其中的记录按照页的方式进行管理。 缓存池是为了解决CPU与磁盘速度之间的鸿沟。 缓存池的大小直接影响能够缓存mysql数据的多少，也就直接影响了MySQL的性能. InnoDB缓存池实例 可以通过参数innodb_buffer_pool_instance参数配置多个缓存池实例，每一个页将会根据哈希值平均分配到不同的缓冲池实例中。
2、缓存池管理 2.1、LRU列表 缓存池一般都是通过LRU（最近最少使用算法）进行管理的。缓冲池中默认页的大小为16K。 InnoDB对传统的LRU算法做了一些优化，在LRU列表中加入了midpoint位置。读取到新的页，并不是直接放入到LRU的首部，而是放入到LRU列表的midpoint位置（中心点插入策略）。 新加入的页何时才能从mid位置加入到new列表（热端），innodb使用innodb_old_blocks_time参数管理，当新读取的页在mid位置等待innodb_old_blocks_time指定的时间之后，将被放入到LRU列表的热端。 2.2、Free列表 LRU列表用来管理已经读取的页，当数据库启动的时候，LRU列表是空的，此时所有的页都存储在Free列表中。 2.3、unzip_LRU列表 innodb从1.0.x开始支持压缩的页的功能，unzip_LRU就是用来管理压缩页的。LRU列表是包含unzip_LRU。 标准页大小为16K，压缩的大小根据压缩比率不同，可分为2k、4k、8k。 unzip_LRU对不同压缩页大小的管理。以需要从缓冲池中分配4kb的页为例。 2.4、Flush列表 在LRU列表中的页被修改之后就变为了脏页，这是将会通过checkPoint机制，将脏页刷新回磁盘中。Flush列表，就是用于存储脏页的，也被称为脏页列表。脏页即存在于Flush列表中也存在与LRU列表中。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘。
3、重做日志缓冲 InnoDB存储将重做日志信息先放到这个缓冲区，然后按一定的频率将其刷新到重做日志文件。 重做日志缓冲区内容刷新到磁盘时机： ①：MasterThread每一秒将重做日志缓冲刷新到重做日志文件 ②：每个事务提交时会将重做日志缓冲刷新到重做日志文件。 ③：当重做日志缓冲池剩余空间小于1/2时，重做缓冲刷新到重做日志文件。</description>
    </item>
    
    <item>
      <title>MySQL表</title>
      <link>https://fruitkang.github.io/mysql/%E8%A1%A8/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/mysql/%E8%A1%A8/</guid>
      <description> 1、简介 介绍表中数据是如何组织和存放的。
2、索引组织表 在innodb存储引擎中，表都是根据主键顺序组织存放的，这种存储方式的表称为“索引组织表”。 主键的创建方式：
 创建表示若指定主键，则使用该主键 若没有指定主键，则判断表中是否存在唯一索引，若存在，则使用唯一所以作为主键 若存在多个唯一索引，则使用定义的第一个作为主键。 若没有唯一索引，innodb存储引擎将会自动创建一个6字节的id主键。
3、Innodb逻辑存储结构 3.1、表空间 innodb存储引擎默认情况只有一个共享表空间idbdata1，即所有数据都放在这个表空间内。如果启用“innodb_file_per_table”参数，则每张表内的数据单独放一个表空间内。需要注意的是每张表的表空间只存放数据。其他的索引、插入缓冲Bitmap页、undo信息、插入缓存索引页、系统事务、二次写缓冲等还是放在原来共享的表空间内。
3.2、段 表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等。数据段就是B+数据的叶子节点、索引段就是B+树的非叶子节点。
3.3、区 区由连续的页组成，任何情况下每个区的大小都为1MB，为了保证区中页的连续性，Innodb存储引擎一次从磁盘申请4~5个区。默认情况下，一个页大小为16K，即一个区中由64个连续的页。
3.4、页 页是innodb磁盘管理的最小单位。 常见页类型：
 数据页
 undo页
 系统页
 事务数据页
 插入缓冲位图页
 插入缓冲空闲列表页
 未压缩的二进制大对象页
 压缩的二进制大对象页
3.5、行 Innodb存储引擎是面向列的，也就是按照行进行数据存放的。
3.6、行格式 innodb由两种行格式，一种为旧版的行格式（redundant），一种为新版的行格式（Compact）
  3.6.1、Compact行格式 </description>
    </item>
    
    <item>
      <title>MySQL锁</title>
      <link>https://fruitkang.github.io/mysql/%E9%94%81/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/mysql/%E9%94%81/</guid>
      <description>MyISAM，表锁设计，读没有问题，但是写的性能相对较差。 Innodb两种行级锁
 共享锁 排他锁  innodb存储引擎支持额外的锁方式，称之为意向锁。意向锁的将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上加锁操。</description>
    </item>
    
    <item>
      <title>Mybatis sqlSession 级别缓存导致引发的现象</title>
      <link>https://fruitkang.github.io/framework/mybatis-sqlsession-%E7%BA%A7%E5%88%AB%E7%BC%93%E5%AD%98%E5%AF%BC%E8%87%B4%E5%BC%95%E5%8F%91%E7%9A%84%E7%8E%B0%E8%B1%A1/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/framework/mybatis-sqlsession-%E7%BA%A7%E5%88%AB%E7%BC%93%E5%AD%98%E5%AF%BC%E8%87%B4%E5%BC%95%E5%8F%91%E7%9A%84%E7%8E%B0%E8%B1%A1/</guid>
      <description>1、背景 ​ 项目最近遇到了了一个奇怪的现象，数据库的数据和前端页面上的数据展示的不一样，只因为方法上面加一个@Transactional注解，这瞬间让我的脑袋上挂了一个大大的问号。
2、代码逻辑  数据库初始数据  数据库就这一条数据，之后所有的逻辑都是在操作这条数据
 “欣赏”一下大致的代码逻辑👀  @RestController @RequestMapping(&amp;quot;/v1/data&amp;quot;) public class DataController { /** * 官方推荐使用构造器注入，我偷个懒 */ @Resource private StudentMapper studentMapper; @GetMapping(&amp;quot;/deal&amp;quot;) public String dealData(@RequestParam(&amp;quot;id&amp;quot;) String id) { Student student = studentMapper.selectById(id); student.setName(&amp;quot;名字被修改了&amp;quot;); //一大堆业务逻辑，但是没有操作过student表 Student student2 = studentMapper.selectById(id); return student2.toString(); } @GetMapping(&amp;quot;/deal/tran&amp;quot;) @Transactional public String dealDataOnTransactional(@RequestParam(&amp;quot;id&amp;quot;) String id) { Student student = studentMapper.selectById(id); student.setName(&amp;quot;名字被修改了&amp;quot;); //一大堆业务逻辑，但是没有操作过student表 Student student2 = studentMapper.selectById(id); return student2.toString(); } }  不要问我为啥会出现这样的无理取闹的逻辑，这是公司的商业秘密，无可奉告😎。（商业秘密就是指不能让别的公司知道，因为太丢脸了🤢）</description>
    </item>
    
    <item>
      <title>Mysql中int(1)和int(10)的区别?</title>
      <link>https://fruitkang.github.io/mysql/mysql%E4%B8%ADint1%E5%92%8Cint10%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/mysql/mysql%E4%B8%ADint1%E5%92%8Cint10%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description> 1、简介  在编程开发中我们经常使用到int(10)，我们经常误以为后面括号里面的数组会影响这个字段能存储的最大值。然而这是错误的。
 不论int(10)还是int(1)在mysql底层都是使用一个int类型4个字节存储的，所以其存储的最大值是一样的。都可以存储无符号整型2的32次方减1。  int(1)和int(10)这里的数字其实是配合zeroFill这个关键词使用的表示的是数据的才能使宽度。
在创建表的时候指定id字段使用zeroFill零填充规则，并且id字段使用int(5)类型，也就是id字段的显示宽度必须为5个字符，当不够五个字符的时候就使用zeroFill进行零填充。
 Tap  不管int(0)还是int(10）使用4个字节进行存储的，所以能够存储的最大数据类型一样。
 虽然数据显示为00001，但是底层存储的依然是1，只是显示的时候填充了零，所以int(1)括号中的数字表示的是显示宽度。
  </description>
    </item>
    
    <item>
      <title>Mysql小知识</title>
      <link>https://fruitkang.github.io/mysql/mysql%E5%B0%8F%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/mysql/mysql%E5%B0%8F%E7%9F%A5%E8%AF%86/</guid>
      <description> 1、复杂的sql要进行explain 主要是查看sql执行的计划的type属性。
2、varchar和char的区别 varchar是变长的，char是定长的，这里指的是字符串数。char类型的数据在长度不够是会使用空格补充，会浪费空间，但因为长度固定，所以char的存储速度比varchar快，char最多能放255个字符和编码方式无关。varchar是变长的，如果长度小于定义的长度，会按照实际长度存储，相比char更节省空间。但是因为是变长的，所以存取的速度 比char要慢。varchar在存储方面，若列的长度小于等于255字节，那需要额外一个字节来记录真实数据长度，若长度大于255，则需要两个字节记录真实数据的长度。
3、mysql中datetime和timestamp的类型的区别  datetime占用8个字节，timestamp占用4个字节
 datetime最大可以表示到9999年，timestamp最大可以表示到2038年
  4、聚集索引与非聚集索引  聚集索引就是索引与表数据存储在一起，聚集索引的叶子节点存储的是整行数据，聚集所以一张表只有一个。
 非聚集索引就是索引与表数据不存储在一起，非聚集索引的叶子节点存储的是列值和主键。一张表可以有多个。
  5、线上CPU暴涨如何排查  通过top命令确认cpu的占用情况
 通过show processlist来查看mysql的线程运行情况
 通过 show open tables where in_use &amp;gt; 0 查看表锁情况。
 通过mysql的error_log查看是否有错误
 通过 SHOW ENGINE INNODB STATUS 查看是否有死锁
 通过慢查询日志，检查是否有慢查询。
 通过iostat来查看磁盘IO情况
  iostat命令安装 yum install sysstat
6、尽量使用not null  null值在mysql中占用时间，而空值不占用空间
 对于字段运行为null的时候，判断条件为is null 或者is not null
 count（字段）不统计null值得列
 null值比任何值都小，从小到大排序时，null值排在最前面
  </description>
    </item>
    
    <item>
      <title>Redis书籍推荐</title>
      <link>https://fruitkang.github.io/books/redis%E6%95%B0%E6%8D%AE%E6%8E%A8%E8%8D%90/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/books/redis%E6%95%B0%E6%8D%AE%E6%8E%A8%E8%8D%90/</guid>
      <description> 0、简介   Redis设计与实现   1、个人声明 这里推荐的书籍本人都进行过阅读，一家之言，如有冒犯，概不负责2、推荐 2.1、Redis设计与实现   此书从从底层数据结构到架构设计、实现原理、工作机制多方面介绍了Redis，非常详细细致。
我Redis大多数文字都是学习此书时候的笔记，同志们可以配置我的笔记学习。
  </description>
    </item>
    
    <item>
      <title>Redis列表</title>
      <link>https://fruitkang.github.io/redis/redis%E5%88%97%E8%A1%A8/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/redis/redis%E5%88%97%E8%A1%A8/</guid>
      <description>1、简介  Redis使用的C语言中没有列表这一结构，所以Redis自己实现这一结构。Redis中列表键底层实现就是一个列表。提到列表就必须提到列表结点和列表这两种结构。
 2、列表结点  列表结点的定义   typedef struct listNode{ //前置结点 struct listNode *prev; //后置结点 struct listNode *next; //结点的值 void *value; }    列表结点的结构图   说明：void *value;   在C语言中void*指针是无类型指针，也就是可以指向任何类型的指针。列表结点使用void*指针来保存结点的值，所以列表的结点可以保存各种不同类型的值。
 3、列表  列表的定义   typedef struct list{ //表头结点 listNode *head； //表尾结点 listNode *tail; //列表所含的结点数量 unsigned long len; //实现多态列表所需的类型特定函数 //结点值复制函数 void *(*dup)(void *ptr) //结点值释放函数 void (*free)(void *ptr); //结点值对比函数 int (*match) (void *ptr,void *key) }    列表的结构图   解释：</description>
    </item>
    
    <item>
      <title>Redis字典</title>
      <link>https://fruitkang.github.io/redis/redis%E5%AD%97%E5%85%B8/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/redis/redis%E5%AD%97%E5%85%B8/</guid>
      <description>1、简介
字典 = 符号表 = 关联数组 = 映射 = 键值对。
字典中的键是独一无二的，不可重复的。
Redis数据库底层使用字典来实现。
字典是Redis中哈希键的底层实现之一。
字典底层使用哈希表作为实现，一个哈希表可以有很多哈希表结点，每个哈希表结点保存了字典中的一个键值对。
2、哈希表结点
\1. 哈希表结点的定义
typedef struct dictEntry{
//键
void* key;
//值
union{
​ void* val；
​ uint64_t u64;
​ int64_t s64;
} v;
//指向下一个哈希表结点，形成链表。
struct dictEntry *next;
} dictEntry;
代码解释：
key代表的键值对中的键，是唯一的，不可重复的。
v代表的键值对中的值，从代码中我们可以知道v是一个联合体类型（文章末尾有联合体的解释）的值，所以v既可以保存任何类型的指针，也可以保存uint64_t类型的整数，又或者可以保存一个int64_t类型整数。
next属性是指向另一个哈希表结点的指针，可以将多个哈希结点形成链表，以此解决哈希冲突。
\2. 哈希表结点的结构
3、哈希表
1、哈希表的定义
// 哈希表
typedef struct dictht{
//哈希表数组
dictEntry **tables;
//哈希表大小
unsigned long size;
//哈希表大小掩码，用于计算索引值，总是等于size-1
unsigned long sizemask;
//该哈希表已有结点的数量
unsigned long used;</description>
    </item>
    
    <item>
      <title>Redis跳跃表</title>
      <link>https://fruitkang.github.io/redis/redis%E8%B7%B3%E8%B7%83%E8%A1%A8/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/redis/redis%E8%B7%B3%E8%B7%83%E8%A1%A8/</guid>
      <description>1、简介  一种有序的数据结构，通过在每个结点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。 跳跃表支持平均O(logN)、最坏O(N)复杂度的结点查找。 Redis使用跳跃表作为有序集合键底层实现之一。 Redis中只有两个地方使用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中作为内部数据结构。  2、总结  跳跃表是有序集合的底层实现之一。 每个跳跃表结点的高度都是在1至32之间的随机数（抛硬币概率）。 跳跃表的头结点的层数为32，分值为0，没有值。 同一个跳跃表中可以存在多个分值相同的结点，但不能存在值相同的结点。 跳跃表中的结点按照分值大小进行排序，当分值相同时，结点按照成员对象的大小进行排序。  3、参考文章 1、什么是跳跃表：https://www.jianshu.com/p/dc252b5efca6
2、跳跃表及其底层是实现</description>
    </item>
    
    <item>
      <title>Redis限流脚本</title>
      <link>https://fruitkang.github.io/redis/redis%E9%99%90%E6%B5%81%E8%84%9A%E6%9C%AC/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/redis/redis%E9%99%90%E6%B5%81%E8%84%9A%E6%9C%AC/</guid>
      <description>@Bean public DefaultRedisScript&amp;lt;Long&amp;gt; limitScript() { DefaultRedisScript&amp;lt;Long&amp;gt; redisScript = new DefaultRedisScript&amp;lt;&amp;gt;(); redisScript.setScriptText(limitScriptText()); redisScript.setResultType(Long.class); return redisScript; } /** * 限流脚本 */ private String limitScriptText() { return &amp;quot;local key = KEYS[1]\n&amp;quot; + &amp;quot;local count = tonumber(ARGV[1])\n&amp;quot; + &amp;quot;local time = tonumber(ARGV[2])\n&amp;quot; + &amp;quot;local current = redis.call(&#39;get&#39;, key);\n&amp;quot; + &amp;quot;if current and tonumber(current) &amp;gt; count then\n&amp;quot; + &amp;quot; return tonumber(current);\n&amp;quot; + &amp;quot;end\n&amp;quot; + &amp;quot;current = redis.call(&#39;incr&#39;, key)\n&amp;quot; + &amp;quot;if tonumber(current) == 1 then\n&amp;quot; + &amp;quot; redis.</description>
    </item>
    
    <item>
      <title>Spring Security学习笔记</title>
      <link>https://fruitkang.github.io/framework/spring-security%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/framework/spring-security%E7%AC%94%E8%AE%B0/</guid>
      <description>一、简介  Spring Security提供了一整套完整的web安全性的完整解决方案。Spring Security两大核心，认证，授权。
 1.1、认证  验证用户为系统的合法主体，通俗：用户能够登录这个系统
 1.2、授权  用户是否有权限做某些事情。
 1.3、Spring Security 与 Shiro的特点  Spring Security 特点   1、和Spring无缝整合
2、全面权限控制
3、专门为web开发而设计
 旧版本不能脱离web环境 新版本可以脱离web环境  4、重量级
  Shiro特点   1、轻量级
2、通用性
 好处：不局限于web环境
 坏处：web环境下特点的需求需要手动编码
   1.4、安全管理技术栈推荐  1、SSM + Shiro
2、Spring Boot / Spring Cloud + Spring Security
 二、Spring Security基本原理 2.1、基本介绍  Spring Security本质是一个过滤器链，有多个过滤器组成，是基于JavaWeb中的过滤器Filter执行的，Filter执行doFilter方法，当过滤器执行放行操作之后才能到下一个过滤器执行。
通过源码可知有众多过滤器，这里介绍3个。
 FilterSecurityInterceptor  方法层级的权限过滤器，基本位于过滤器的最底层。</description>
    </item>
    
    <item>
      <title>Spring Spel表达式</title>
      <link>https://fruitkang.github.io/framework/spring-spel%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/framework/spring-spel%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>1、spel表达式简介 Spring表达式语言(简称“SpEL”)是一种功能强大的表达式语言，支持在运行时查询和操作对象图。 语言语法类似于Unified EL，但提供了额外的功能，最显著的是方法调用和基本的字符串模板功能。
2、测试环境搭建 1、环境 java8 + maven
2、搭建 1、maven导入spel表达式所有的jar包
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-expression&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.12.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.12.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  3、Spel表达式解析 1、单引号表示字符串字面值 /** * 使用单引号表示字符串字面值 */ private static void stringConstTest() { /*负责解析表达式的接口*/ ExpressionParser parser = new SpelExpressionParser(); /*使用单引号表示字符串字面值*/ String expression = &amp;quot;&#39;Hello World&#39;&amp;quot;; Expression exp = parser.parseExpression(expression); String message = (String) exp.getValue(); /*结果为：Hello World */ System.out.println(message); }  String expression = &amp;ldquo;&amp;lsquo;Hello World&amp;rsquo;&amp;rdquo;; 为Spel表达式，其中使用单引号表示字符串字面值。
2、使用spel调用方法 /** * spel调用方法 */ private static void callMethodTest() { /*负责解析表达式的接口*/ ExpressionParser parser = new SpelExpressionParser(); /*调用字符串的concat方法*/ Expression exp = parser.</description>
    </item>
    
    <item>
      <title>docker常用命令</title>
      <link>https://fruitkang.github.io/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description> 1、启动一个实例 docker run -p 3306:3306 --name mysql -v /mydata/mysql/log:/var/log/mysql -v /mydata/mysql/data:/var/lib/mysql -v /mydata/mysql/conf:/etc/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 --------------------------------------- 参数说明-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口 -v /mydata/mysql/conf:/etc/mysql：将配置文件夹挂载到主机 -v /mydata/mysql/log:/var/log/mysql：将日志文件夹挂载到主机 -v /mydata/mysql/data:/var/lib/mysql/：将配置文件夹挂载到主机 -e MYSQL_ROOT_PASSWORD=root：初始化 root 用户的密码  2、进入容器内文件系统 #mysql为容器名 docker exec -it mysql /bin/bash  3、常用命令 #查看正在运行的docker容器 docker ps #查看所有的docker容器 docker ps -a #设置docker容器每次都是自动启动 docker update redis --restart=always  </description>
    </item>
    
    <item>
      <title>maven常用配置</title>
      <link>https://fruitkang.github.io/maven/maven%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/maven/maven%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</guid>
      <description> 1、配置阿里云镜像 &amp;lt;mirrors&amp;gt; &amp;lt;mirror&amp;gt; &amp;lt;id&amp;gt;aliyunmaven&amp;lt;/id&amp;gt; &amp;lt;mirrorOf&amp;gt;*&amp;lt;/mirrorOf&amp;gt; &amp;lt;name&amp;gt;阿里云公共仓库&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;https://maven.aliyun.com/repository/public&amp;lt;/url&amp;gt; &amp;lt;/mirror&amp;gt; &amp;lt;/mirrors&amp;gt;  2、配置1.8编译项目 &amp;lt;profiles&amp;gt; &amp;lt;profile&amp;gt; &amp;lt;id&amp;gt;jdk-1.8&amp;lt;/id&amp;gt; &amp;lt;activation&amp;gt; &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt; &amp;lt;jdk&amp;gt;1.8&amp;lt;/jdk&amp;gt; &amp;lt;/activation&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt; &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt; &amp;lt;maven.compiler.compilerVersion&amp;gt;1.8&amp;lt;/maven.compiler.compilerVersion&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;/profile&amp;gt; &amp;lt;/profiles&amp;gt;  3、maven排除继承父类的插件 &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;skip&amp;gt;true&amp;lt;/skip&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;  </description>
    </item>
    
    <item>
      <title>mybatis常用配置</title>
      <link>https://fruitkang.github.io/framework/mybatis%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/framework/mybatis%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</guid>
      <description> 1、mybatis日志输出配置 configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  </description>
    </item>
    
    <item>
      <title>springboot集成mybatis-plus</title>
      <link>https://fruitkang.github.io/framework/springboot%E9%9B%86%E6%88%90mybatis-plus/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/framework/springboot%E9%9B%86%E6%88%90mybatis-plus/</guid>
      <description>1、导入依赖
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  2、配置
2.1 配置数据源：
①导入数据驱动
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.17&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  spring: datasource: username: root password: root url: jdbc:mysql://192.168.1.12:3306/gulimall_pms driver-class-name: com.mysql.jdbc.Driver  2.2配置mybatis-plus
①mapperScan设置mapper接口
@MapperScan(&amp;quot;com.atguigu.gulimall.product.dao&amp;quot;) @SpringBootApplication public class GulimallProductApplication { public static void main(String[] args) { SpringApplication.run(GulimallProductApplication.class, args); } }  ②设置mapper文件的位置
mybatis-plus: mapper-locations: classpath:/mapper/**/*.xml  ③设置主键自增
mybatis-plus: mapper-locations: classpath:/mapper/**/*.xml global-config: db-config: id-type: auto  </description>
    </item>
    
    <item>
      <title>网络书籍推荐</title>
      <link>https://fruitkang.github.io/books/%E7%BD%91%E7%BB%9C%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</link>
      <pubDate>Tue, 20 Jun 2023 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/books/%E7%BD%91%E7%BB%9C%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</guid>
      <description> 0、简介   深入理解Linux网络 网络是怎样连接的   1、个人声明 这里推荐的书籍本人都进行过阅读，一家之言，如有冒犯，概不负责2、推荐 2.1、深入理解Linux网络   本书从问题出发，帮助我们解决了工作中的许多困惑，个人认为对我们程序员来说非常重要。
例如下面的问题在本书中都能得到答案
  2.2、网络是怎样连接的   这本书非常的简单易懂，介绍了当我们从浏览器输入一个地址到服务器给我们一个响应的整个过程。
  </description>
    </item>
    
    <item>
      <title>位图BitSet</title>
      <link>https://fruitkang.github.io/works/bitset%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 20 Aug 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/works/bitset%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description> 1、简介  在谈什么是位图之前我们先来看一道&amp;rdquo;非常简单的题&amp;rdquo;：有40亿个无符号的整型数据，现在给定一个目标数字，判断这个数字是否在这40亿数据中。题目看起来确实非常简单，有的同学说直接遍历一遍不就ok了吗？还有的同学给出了更高效的查找方式就是将这些数字排序然后进行二分查找。但是，这是有问题的，问题并不在于你搜索这个数字的效率问题，而是你在遍历也好排序也罢，这些数字在内存中放的下么？
一个整型int就是4个字节，10亿个int差不多已经需要4G的内存了，40亿个int就是16G。所以这里方法行不通的根本原因实际上是内存不够，但是我们今天的讲的位图却能很好的帮助我们处理这个问题。
 2、位图模型  既然根本原因是这些数据用int放不下，那么是否有更小的东西标记这些数字呢？没错，有的同学想到了，char只占一个字节或许能表示一个数字，但是随着数字位数的增多，依旧不可能使用一个字符表示一个数字，这就意味着小于4G内存还是不能解决这个问题。
其实说到这里，我们的问题就转化为如何使用更小的内存单元来标记一个数字，而在程序中我们最小的访问单位的bit位，所以现在我们一起来看使用比特位如何标记(映射)这些数据。
现在我们发现，4个字节本来只能存储一个int，而现在使用位图我们就存了(映射)32个数字，意味着16G/32约等于500m左右我们就能映射这些数据。
 3、工作的使用  使用redis中提供的bitset结构统计活跃用户数
 </description>
    </item>
    
    <item>
      <title>mq保证消息不丢失</title>
      <link>https://fruitkang.github.io/works/mq%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/</link>
      <pubDate>Wed, 20 Jul 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/works/mq%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/</guid>
      <description> 一、简介  项目中使用到Kafka消息中间件，例如订单抽取的就用到了Kafka消息中间件。使用到Kafka就会涉及消息不丢失的问题。
 二、解决方案 2.1、解决超时问题导致的消息丢失问题 Kafka提供了消息确认的机制保证消息不丢失问题，但是也会存在ACK超时的这种情况，这种情况下我们因该如何解决呢。
  在发送之前可以在数据库记录下这条消息的并且状态为未确认，之后收到ACK之后修改数据库为已确认.
 有一个定时任务需要将消息未确认的消息进行重新投递
 消费者需要确保消息的幂等。
   2.2、通过配置解决不丢失问题  这里以Kafka消息中间件为例。
 Kafka提供的解决方案   Kafka分为三部分，分别为生产者、borker、消费者，要保证消息不丢失就需要先保证这三部分消息不丢失，
可以通过配置生产者和消费者的ACK确认机制以保证消息不丢失
可以通过配置broker消息持久化的时机以保证broker消息不丢失
  三、总结  通过消息状态表保证消息至少投递一次 定时任务兜底 消费者保证消息幂等  </description>
    </item>
    
    <item>
      <title>外部接口中心化处理</title>
      <link>https://fruitkang.github.io/works/%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%BF%83%E5%8C%96%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 20 Jul 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/works/%E5%A4%96%E9%83%A8%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%BF%83%E5%8C%96%E5%A4%84%E7%90%86/</guid>
      <description>一、简介  系统中有大量与外部系统进行交互的接口，例如在我们的系统进行一些用户、设备的增删改之后需要及时调用对方接口并将数据同步给外部系统，之前的方案耦合性太高，不便于管理和扩展。
此次修改方案如下
 二、当前问题  当前与外部系统交互方式
当前系统在需要与外部系统交互的接口中直接调用对方接口进行数据同步，这导致调用外部系统的接口散落到系统的各个地方，不便于管理，耦合性过高。
 三、解决方案  1、使用观察者模式搭建外部交互服务，所以需要与外部系统交互的服务都通过此服务进行集中化处理。
2、提供一个spring-starter包
 1、在这种个包中提供了@Insert、@Delete、@Update、@Full
 insert注解用于数据添加的时候
 delete注解用于数据删除的时候
 update注解用于数据修改的时候
 full注解用于全量数据同步的时候
  public @interface Insert { /** * 同步数据类型,指明需要同步的数据类型 * @return */ DataTypeEnum dataType(); /** * 一个Spring EL表达式，用于解析同步数据的id * @return */ String parseIdList(); /** * * 当参数或返回值太过于复杂，Spring EL表达式不好解析的时候可以使用此类来处理参数得到需要同步的数据id * @return */ Class&amp;lt;? extends ParseIdService&amp;gt; ParseIdClass() default DefaultParseIdService.class; }  2、提供一个AOP切面，在这个切面中主要去解析方法上面写的上述提供的结果注解，然后得到需要同步的数据，然后请求对外服务让对外服务去帮助我们去同步数据。
 3、在需要同步的方法上标明上面提供的注解即可。
 四、优势  将所有与外部交互的接口放在对外微服务中处理，并在对外微服务中使用观察者模式便于扩展。</description>
    </item>
    
    <item>
      <title>Nginx使用总结</title>
      <link>https://fruitkang.github.io/nginx/nginx%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/nginx/nginx%E9%85%8D%E7%BD%AE/</guid>
      <description>一、Nginx的作用 1.1、反向代理  简述   接受外部请求，然后把请求转发到后台服务器，然后将后台服务器的结果返回给客户端。
 1.2、负载均衡  简述   将前端的请求根据策略分发到不同的后端服务器进行处理
负载均衡策略
 轮询   依次将请求分配到不同的服务器，当某台服务器宕机之后，将自动去除该故障系统，用户访问不受影响。
  权重   将请求按照配置的权重分发到服务器，服务器之间的规格不同的情况。
  ip_hash   每个请求都按照请求IP地址进行hash运算并转发到对应服务器，可以保证同一个IP的用户请求能转发到同一台服务器。
  url_hash   按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率
注意：Nginx本身不支持url_hash，必须安装Nginx 的hash软件包
  fair   此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配
注意：Nginx本身不支持fair，必须下载Nginx的upstream_fair模块；
  1.3、动静分离  简述   在前后端项目中通常把前端项目部署到nginx中，前端对一些页面的请求只需要经过nginx就行，无需经过后台服务器。
动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，说白了就是把api请求接口通过反向代理把请求分配到对应的后台服务器上，静态资源(html,image,js,css)这些就由Nginx的静态资源服务器的功能来处理。
  举例  server { listen 80; server_name localhost; # 所有静态请求都由nginx处理，存放目录为html location /report { alias D:/nginx-1.</description>
    </item>
    
    <item>
      <title>Redis删除大Key</title>
      <link>https://fruitkang.github.io/redis/redis%E5%88%A0%E9%99%A4%E5%A4%A7key/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/redis/redis%E5%88%A0%E9%99%A4%E5%A4%A7key/</guid>
      <description>0、redis中的大Key    大Key 解释     hash 映射表   set 集合   zset 有序集合   list 列表    1、问题 线上出现Redis大Key该如何删除？
1、低峰期删除  在业务的低峰期删除大Key，例如凌晨4点的时候去删除大Key，虽然这依旧会导致阻塞问题，但是影响比较小，适用于QPS小的业务。
 2、分批删除法    大Key 分批删除方法       hash 使用hscan分批删除 hscan命令用来迭代hash表中键值对，然后通过hdel命令逐个删除每个键值对    set 使用Srandmember命令分批删除 Srandmember 命令用于返回集合中的一个或多个随机元素，然后使用Srem命令删除元素    zset 使用Zremrangebyrank 命令分批删除 Zremrangebyrank 命令用于移除有序集中，指定排名(rank)区间内的所有成员。    list 使用Lpop或Rpop命令逐个删除 Lpop 命令用于移除并返回列表的第一个元素。Rpop 命令用于移除并返回列表的最后一个元素。     3、异步删除 Redis4.</description>
    </item>
    
    <item>
      <title>Redis压缩列表</title>
      <link>https://fruitkang.github.io/redis/redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/redis/redis%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/</guid>
      <description>一、简介  压缩列表是列表键和哈希键底层实现之一。
压缩列表是Redis为了节省内存而开发的。
压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构。
一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。
 二、压缩列表 2.1、压缩列表结构 2.2、压缩列表结构解释（重点）    属性 类型 长度 用途     zlbytes uint32_t 4字节 记录整个压缩列表占用的内存字节数：在对压缩列表进行内存重分配或者计算zlend的位置时使用   zttail uint32_t 4字节 记录压缩列表尾结点距离压缩列表起始地址有多少字节：通过这个偏移量，程序无需遍历整个压缩列表就可以确定尾节点   zllen uint16_t 2字节 记录压缩列表中节点的数量：当这个属性的值小于UINT16_MAX（65535）时，这个属性的值就是压缩列表当前所包含节点的个数。当这个属性等于UINT16_MAX（65535）时，节点的真实数量需要遍历整个压缩列表才能知道   entryX 列表节点 不定 压缩列表的各个节点，节点的长度由节点的内容决定   zlend uint8_t 1字节 特殊值0xFF（十进制255），用于标记压缩列表的尾端    2.3、压缩列表节点 2.3.1、压缩列表节点结构 2.3.2、压缩列表节点结构解释（重点）  previous_entry_length属性以字节为单位，记录了压缩列表中前一个节点的长度。   当前一字节的长度小于254字节，previous_entry_length占用1字节。
当前一字节的长度大于等于254字节，previous_entry_length占用5字节，其中第一字节会被设置为0xFE（254），而之后的四个字节用来保存前一字节的长度。
因为后面节点记录前面节点的长度，所以可以根据当前节点的起始指针就算出前一个节点的起始指针。也就可以实现从表尾节点向表头节点的遍历过程。
  encoding属性记录了节点保存数据的类型以及长度。
 content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度有encoding属性决定。
  3、连锁更新（详细请看书）  连锁更新在最坏情况下需要多压缩列表进行N次空间重新分配操作，而每次空间分配的最坏时间复杂度为O(N)，所以整个连锁更新的最坏复杂为O(n*n)；连锁更新有较高的复杂度，但他真正造成性能问题的几率是很低的。</description>
    </item>
    
    <item>
      <title>Redis对象</title>
      <link>https://fruitkang.github.io/redis/redis%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/redis/redis%E5%AF%B9%E8%B1%A1/</guid>
      <description>一、简介  Redis并没有使用我们之前介绍的数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统。每种对象都用到了至少一种我们前面介绍的数据结构。
 二、对象的类型和编码  Redis使用对象表示数据库中的键和值，每次当我在Redis的数据库添加一个键值对的时候，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）。
 2.1、redisObject的结构  typedef struct redisObject{ //类型 unsigned type:4; //编码 unsigned encoding:4; //指向底层实现数据结构的指针 void *ptr; //... }  解释：
 type属性：指明当前Redis对象时什么类型。有以下五种类型。     类型常量 对象名称     REDIS_STRING 字符串对象   REDIS_LIST 列表对象   REDIS_HASH 哈希对象   REDIS_SET 集合对象   REDIS_ZSET 有序集合对象     encoding属性：指明了这个对象使用了什么数据结构作为对象的底层实现。encoding设定对象所使用的编码，而不是为特定的类型对象关联一种固定的编码，极大的提升了Redis的灵活性和效率。
 ptr属性：指向对象底层使用数据结构的实现。
  举例：
 2.2、字符串对象 1、字符串对象有三种编码方式</description>
    </item>
    
    <item>
      <title>Redis整数集合</title>
      <link>https://fruitkang.github.io/redis/redis%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/redis/redis%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</guid>
      <description>一、简介   整数集合是Redis集合键的底层实现之一。 整数集合（intset）中不会出现重复元素。 整数集合可以保存类型为int6_t、int32_t、int63_t的整数值。 整数集合底层使用数组来保存值，且保存的值按从小到大有序排列。 整数集合   二、整数集合结构 2.1、定义  typedef struct intset{ //编码方式 uint32_t encoding; //集合包含的元素数量 uint32_t length; //保存元素使用的容器（数组） int8_t contents[]; }   2.2、解释  encoding属性将会决定contents数组的真正类型。其中encoding属性可以为以下三个值：   当encoding属性为INTSET_ENC_INTT16，那么contents数组就是一个int16_t类型的数组。
当encoding属性为INTSET_ENC_INTT32，那么contents数组就是一个int32_t类型的数组。
当encoding属性为INTSET_ENC_INTT64，那么contents数组就是一个int64_t类型的数组
  length属性记录当前整数集合包含的元素数量，也就是contents数组的长度。
 虽然contents数组声明为int8_t类型的，但实际contents数组不会保存任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值。contents数组的元素是按照从小到大有序排列，且不会重复。
  2.3、整数集合的升级 2.3.1、简介  当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要整体先进行升级，然后才能将新元素加入到整数集合中。
 2.3.2、整数集合升级步骤  原整数集合中元素的类型为int16_t类型。如图所示：   给集合中添加一个int32_t类型的值（65535）。因为原contents数组保存的是3个int16_t类型的元素，也就是原数组的长度为16*3=48位。现在由于要添加一个int32_t的元素，所以必须将数组中的所有元素进行升级为int32_t类型，所以升级之后数组的长度（包括要添加的新元素）为32*4=128位。所以集合将会变为如下图所示。   现在集合中的元素有【1,2,3,65535】，元素3在四个元素中排名第三，则它将被移动到contents数组索引为2的位置（64位~95位）。   现在集合中的元素有【1,2,3,65535】，元素2在四个元素中排名第二，则它将被移动到contents数组索引为1的位置（32位~63位）。   现在集合中的元素有【1,2,3,65535】，元素2在四个元素中排名第1，则它将被移动到contents数组索引为0的位置（0位~31位）。   现在集合中的元素有【1,2,3,65535】，元素65535在四个元素中排名第4，则它将被移动到contents数组索引为3的位置（95位~127位）。  2.3.3、注意：  encoding属性和length属性是在将65535添加到集合中之后才修改的，上面的图有一点小错误。</description>
    </item>
    
    <item>
      <title>Redis简单动态字符串</title>
      <link>https://fruitkang.github.io/redis/redis%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/redis/redis%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>一、简介  简单动态字符串简称为SDS，是Redis中的一种数据结构，作用就是为了表示字符串。
 二、问题  我们知道Redis是由C语言编写的，那为何Redis不使用C语言中传统的字符串表示，而是重新定义了一个简单动态字符串的结构来表示字符串呢？
 三、简单动态字符串 3.1、简单动态字符串的定义 struct sdshdr{ //记录buf字符数组中已经使用的字符的数量 int len; //记录buf数组中未使用的字符的数量 int free; //字符数组，用来保存字符串 char buf[]; }  3.2、简单动态字符串的结构图 3.3、细节解释  free属性的值为0，代表该SDS没有分配任何未使用空间。
 len属性的值代表的值不包括字符串结尾的字符 ‘\0’ 。
 在SDS中遵守了C语言中以 ‘\0’ 为字符串结尾的惯例。遵守这一规定的好处就是直接重用C字符串的一部分函数。
  3.4、C语言字符串与简单动态字符串的区别    C字符串 SDS简单动态字符串     获取字符串长度时间复杂度为O(N) 获取字符串长度时间复杂度为O(1)   API不安全，可能导致缓冲区溢出 API安全，不会导致缓冲区溢出   修改字符串N，必然需要重分配内存N次 修改字符串N次，最多需要分配N次内存   只能保存文本数据 可以保存文本，二进制   可以使用全部库中的函数 可以使用部分库中的函数    1、SDS常数复杂度获取字符串长度  因为C语言字符串不记录本身的长度信息，所以要获取C字符串长度，就必须遍历整个C字符串，这个操作的复杂为O(n)。但是简单动态字符本身使用len属性记录其长度，所以获取一个SDS长度的复杂度为O(1)。</description>
    </item>
    
    <item>
      <title>Redis脑裂</title>
      <link>https://fruitkang.github.io/redis/redis%E8%84%91%E8%A3%82/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/redis/redis%E8%84%91%E8%A3%82/</guid>
      <description> 1、问题严重性 Redis脑裂会导致数据丢失。
2、问题现象 在Redis中集群中多个master。
3、出现条件  redis集群
 redis集群以一主多从架构
 master进行写数据，slave进行读数据。
  4、问题出现的原因  一般生产环境中都会涉及到redis集群，并且以一主多从的架构进行搭建redis集群，master中进行写操作，slave中进行读操作，master写入的数据将会同步到slave中。
上诉的这种redis集群架构在极端情况下将会发生redis脑裂这种事。当redis集群内部出现问题的时候，master与从slave出现问题，无法正常连接，但master与客户端是能够正常连接的，这时候哨兵发现了master断开连接了，所以会在slave中重新选取新master，这时候集群就出现了两个master，旧的客户端依旧连接的旧的master，新的客户端会连接到新master，此时旧的客户端往旧master写入的数据无法同步到slave中，但读数据是从slave中读取的，所以这部分数据是无法读取到的。
上诉也就是出现了读不到数据的问题。严重的问题出现在当旧master重新与slave取得联系之后，旧的master就会从master转变为slave，从master转变为slave意味着旧master的数据将会被全部清空然后从新master同步数据。这就意味着旧客户端写入旧master的数据将会被清空丢失。
 5、解决方案  主要通过设置参数来解决
将参数min-slave-to-write为1，设置主库能进行数据同步的最小从库数据为1，当小于这个参数的时候主库将会拒绝客户端写入，返回错误给客户端。
将参数min-slave-max-lag=10，设置主从库进行数据复制时，从库向主从发送ack消息的最大延迟为10秒，当旧master超过10秒没有收到salve的的回复的时候，老master将会拒绝客户端写入，返回错误给客户端。
 </description>
    </item>
    
    <item>
      <title>WebSocket</title>
      <link>https://fruitkang.github.io/others/websocket/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/others/websocket/</guid>
      <description> 1、WebSocket基本原理 WebSocket是一个允许在单一TCP连接上进行全双工消息通信的网络协议。
连接升级，将http连接升级为WebSocket连接。
一个客户端对应一个endPoint实例。
2、WebSocket生命周期 1、简介  与http技术不同，WebSocket具有生命周期。此生命周期由WebSocket协议进行支撑。在Servlet技术中，底层协议仅仅定义了请求/响应交互，这次的交互完全独立于下一次交互。然而在WebSocket协议定义了客户端与服务端间长时间存活的专用tcp连接。正因如此，在定义更长时间的生命周期方面，WebSocket比传统的web请求/响应模型更进一步。 WebSocket协议定义了WebSocket连接上往返传输数据各个块的格式。WebSocket协议中包含两种主要类型的帧：数据帧和控制帧。 控制帧用于执行协议内部功能逻辑的数据传输。例如，定义了关闭帧（close frame）。关闭帧是一种特殊的传输，它意味着发送者准备关闭连接。Ping帧和Pong帧是用来服务连接健康性检测的数据传输。如果WebSocket希望检测其到WebSocket对等节点的连接的健康性，它可以发送Ping帧。当WebSocket对等节点收到Ping帧后，必须响应Pong帧。  2、生命周期 API级别的生命周期
 打开事件 @OnOpen
 消息事件 @OnMessage
 错误事件 @OnEerror
 关闭事件 @OnClose
  3、端点实例数目及线程机制  java WebSocket编程模型与java Servlet 编程模型的关键差异在于，java Servlet实例可能被多个线程同时调用，每个线程用于处理不同客户端的请求/响应交互。然而，在WebSocket中，每个客户端都对应着一个端点实例，所以无需多线程处理。  3、配置与Session 1、简介 java WebSocket API中两个重要的对象：Session和EndpointConfig。
 session表示单个客户端的状态。
 EndpointConfig表示多个客户端共享的状态。
  </description>
    </item>
    
    <item>
      <title>免费工具</title>
      <link>https://fruitkang.github.io/tools/%E5%85%8D%E8%B4%B9%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/tools/%E5%85%8D%E8%B4%B9%E5%B7%A5%E5%85%B7/</guid>
      <description>常用免费接口
聚合数据提供30大类,160种以上基础数据API服务,国内最大的基础数据API服务，下面就罗列一些免费的各类API接口。
   接口 地址     手机号码归属地API接口 https://www.juhe.cn/docs/api/id/11   历史上的今天API接口 https://www.juhe.cn/docs/api/id/63   股票数据API接口 https://www.juhe.cn/docs/api/id/21   全国WIFI接口 https://www.juhe.cn/docs/api/id/18   星座运势接口 https://www.juhe.cn/docs/api/id/58   黄金数据接口 https://www.juhe.cn/docs/api/id/29   语音识别接口 https://www.juhe.cn/docs/api/id/134   周公解梦接口 https://www.juhe.cn/docs/api/id/64   天气预报API接口 https://www.juhe.cn/docs/api/id/73   身份证查询API接口 https://www.juhe.cn/docs/api/id/38   笑话大全API接口 https://www.juhe.cn/docs/api/id/95   邮编查询接口 https://www.juhe.cn/docs/api/id/66   老黄历接口 https://www.juhe.cn/docs/api/id/65   网站安全检测接口 https://www.juhe.cn/docs/api/id/19   手机固话来电显示接口 https://www.juhe.cn/docs/api/id/72   基金财务数据接口 https://www.</description>
    </item>
    
    <item>
      <title>国际化功能的中心化处理</title>
      <link>https://fruitkang.github.io/works/%E5%9B%BD%E9%99%85%E5%8C%96%E5%8A%9F%E8%83%BD%E7%9A%84%E4%B8%AD%E5%BF%83%E5%8C%96/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/works/%E5%9B%BD%E9%99%85%E5%8C%96%E5%8A%9F%E8%83%BD%E7%9A%84%E4%B8%AD%E5%BF%83%E5%8C%96/</guid>
      <description> 一、简介 1.1、原有方案  当前系统中已经有国际化的功能了，这里的国际化功能是通过Spring提供的i18n功能去处理的，也就是通过在resource目录下面建立对应的国际化文件，然后在上下文中进行埋点（也就是国际化的code编码）。
每个微服务都有自己的国际化文件，不便于统一处理，例如现在要为所有的微服务添加一个关于金额转换的国际化功能，就需要改变所有微服务。
 1.1.1、缺点   上述的方案导致国际化的功能散落在服务的各个地方，也就是需要国际化功能的地方都需要建立自己的国际化文件并指定自己上下问的code编码。 不便于管理和扩展，举个例子，在开发过程中A和B开发分别在自己的分支上进行开发，然后分别定义了自己的国际化编码为code1，当分支合并之后发现code编码冲突了导致一方必须重新修改自己的编码。   1.2、我的方案  建立统一的国际化微服务，每个微服务在需要的时候去调用国际化微服务的的接口，完成国际化需求。
  建立国际化微服务 提供统一的sdk供每个微服务使用，sdk中提供了本地缓存，本地缓存中缓存当前微服务的国际化数据， 本地缓存具有过期时间，可以解决缓存长期不一致问题。 当国际化微服务数据修改之后将发mq消息给各个微服务，微服务将消费消息并修改本地缓存，保证缓存数据的一致性。 国际化微服务提供了前端页面供各用户去添加和修改国际化数据。  1.3、数据设计 service_name：微服务名，指定该国际化数据属于哪个微服务
local：语言标识，指定该数据属于那种语言
code：国际化数据的code码
 国际化功能可以看做是一个大的map集合，整个map的key为service_name:local:code，根据这个key就可以得知是哪个微服务需要code的那种语言的文案。
 </description>
    </item>
    
    <item>
      <title>布隆过滤器</title>
      <link>https://fruitkang.github.io/redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/redis/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>1、简介  本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。
相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。
 2、实现原理  HashMap 的问题   讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。
还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。
  布隆过滤器数据结构   布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：
如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：
Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：
  注意    值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。</description>
    </item>
    
    <item>
      <title>数据订阅服务搭建</title>
      <link>https://fruitkang.github.io/works/%E6%95%B0%E6%8D%AE%E8%AE%A2%E9%98%85%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/works/%E6%95%B0%E6%8D%AE%E8%AE%A2%E9%98%85%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</guid>
      <description> 一、简介  系统当前有需求与外部系统进行数据交互，交互的流程如下
  实现方案    当外部系统登录之后再redis中添加一个记录，其中key为用户唯一标识，过期时间为心跳间隔时间。 每次心跳请求都去更新上面redis记录的过期时间，保证心跳。 当用户发起订阅数据请求（请求中提供了推送数据的地址）之后，在quatz定时任务中添加数据推送的定时任务，这个定时任务的唯一标识就是该用户的唯一表示。并且定时任务每次执行时都判断redis1记录是否过期，如果过期则将该定时任务自动停止并删除该定时任务。 当用户发送停止数据推送的时候在quartz定时任务框架中停止并删除对应定时任务。   </description>
    </item>
    
    <item>
      <title>缓存穿透、击穿、雪崩该怎么办？</title>
      <link>https://fruitkang.github.io/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/redis/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%87%BB%E7%A9%BF%E9%9B%AA%E5%B4%A9%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E/</guid>
      <description> 1、缓存穿透 1、问题描述 大量请求一些不会走缓存的数据，导致大量请求直接打到DB，导致系统崩溃。例如请求user_id=-1的用户信息，由于数据库不存在用户id为负数的用户信息，所以缓存就会一直不命中，所以请求一直打到DB中。
2、解决方案  前端校验：通过前端校验，使不合法的请求不能够请求到服务中。
 后端校验：对于不合法的参数，直接返回错误提示。
 空值缓存：对数据库中查询到的空值做缓存，且让空值的缓存时间较短一点。
 hash校验：使用数据量不多的场景，将数据存在hash中，每次请求时先判断hash中是否存在，不存在则直接返回。
 位图标记：使用比特位进行标志
 布隆过滤器：不能100%的拦截。
  2、缓存击穿 1、问题描述 某一个热点数据在某一刻缓存过期，大量请求直接打到了DB。
2、解决方案  分布式锁，通过setnx或zookeeper实现分布式锁，使得只有一个good_id=1能够进入DB，其他请求就可以拿到第一个请求设置的缓存了。
 单机锁，集群数量不多的时候可以使用单机锁控制，假设只有10太机器，那么最多也就有10个请求直接打到DB，问题不大，没有必要使用分布式这种高级锁。
 二级缓存，当redis中不存在的时候可以去二级缓存中去找，防止直接打到DB，二级缓存可以使用内存缓存等方式。
 热点数据不过期，将热点数据设置永久不过期。
  3、缓存雪崩 1、问题描述 在某一时刻，大量缓存失效，大量请求直接打到DB中。
2、解决方案  缓存失效的时间随机一些，降低同时失效的概率
 上锁
 二级缓存
  Tap  缓存击穿指的是单个key过期导致的大量关于这个可以的请求直接打到DB。 缓存雪崩指的是许多key过期导致大量请求直接打到DB。
 </description>
    </item>
    
    <item>
      <title>获取ip的工具类</title>
      <link>https://fruitkang.github.io/tools/%E8%8E%B7%E5%8F%96ip%E5%B7%A5%E5%85%B7%E7%B1%BB/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/tools/%E8%8E%B7%E5%8F%96ip%E5%B7%A5%E5%85%B7%E7%B1%BB/</guid>
      <description>/** * 获取本机ip * * @return 本机ip列表 */ public static List&amp;lt;String&amp;gt; getIp() { //1、获取本机下的所有网卡 Collection&amp;lt;NetworkInterface&amp;gt; networkInterfaces = NetUtil.getNetworkInterfaces(); if (CollectionUtil.isEmpty(networkInterfaces)) { throw new BaseRuntimeException(&amp;quot;无法获取当前主机下的网卡&amp;quot;); } networkInterfaces = networkInterfaces.stream().filter(networkInterface -&amp;gt; { try { return !networkInterface.isLoopback(); } catch (SocketException e) { throw new BaseRuntimeException(&amp;quot;获取本机ip发生SocketException&amp;quot;, e); } }).collect(Collectors.toList()); List&amp;lt;String&amp;gt; ips = Lists.newArrayList(); networkInterfaces.forEach(networkInterface -&amp;gt; { //获取该网卡下的所有地址 Enumeration&amp;lt;InetAddress&amp;gt; addresses = networkInterface.getInetAddresses(); while (addresses.hasMoreElements()) { InetAddress inetAddress = addresses.nextElement(); //过滤环回地址 if (!inetAddress.isLoopbackAddress()) { if (&amp;quot;127.0.0.1&amp;quot;.equalsIgnoreCase(inetAddress.getHostAddress())) { continue; } if (inetAddress instanceof Inet6Address) { continue; } if (inetAddress instanceof Inet4Address) { ips.</description>
    </item>
    
    <item>
      <title>解决报表查询缓慢的问题</title>
      <link>https://fruitkang.github.io/works/%E8%A7%A3%E5%86%B3%E6%8A%A5%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/works/%E8%A7%A3%E5%86%B3%E6%8A%A5%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>一、问题介绍  项目中报表的查询接口的性能较慢，虽然目前运营那边可以接受但是考虑到后续项目的发展，当前必须进行优化。
 二、问题查找 2.1、SQL问题  当前报表查询的接口的部分sql的书写并不规范，导致sql并未命中索引。例如前端要求查询【2022年10月~2022年12月】的数据，部分sql书写未select xxxx from table where date_fromat(date) between 2022-10 and 2022-12，这种在索引字段上加函数的操作导致索引失效，这只是其中一种情况，还有其他情况，例如未使用覆盖索引、使用了临时表、分组之后进行了多余的排序、不满足最左匹配、甚至没有建立索引的情况。
 2.2、数据量问题   当前报表查询的接口主要是直接查询订单表数据。 订单表为业务的核心数据表，随着日后的发展订单表的数据量也将逐渐增大，报表查询性能也将下降。    三、问题解决 3.1、优化sql  按照规范书写SQL，把在索引字段上使用函数的情况放到Java程序中去处理参数为合适的数据格式。
根据需求建立索引，并尽量使用覆盖索引或索引下推以减少回表次数。
SQL需要满足最左匹配。
分组之后如果无需排序可以使用group by xxxx order by null减少不必要的排序
等等其他一些方式
 3.2、解决数据量较大问题 3.2.1、数据抽取方案（采用）  简介   我们的系统是Saas系统，系统中有商户、运营商等业务角色。
将订单表根据这些业务角色分别抽取出所需要的年运营商数据表、月运营商数据表、日运营商数据表等各种抽取表，后续运营商按照年查询数据的之后直接到对应的表里面直接查询，无需查询订单表等核心表。
  实现方案   在订单入库的时候发一个订单的mq消息，数据抽取服务收到这个消息之后同步去修改对饮运营商的日、月、年的抽取表。
加一个定时任务，每天晚上去全量抽取前一天的数据，去兜底mq消息消费失败的情况。
写一个接口，在上线之后抽取之前没有抽取的数据。
  方案优势    查询数据量极具变小，例如一个运营商一天有一万条数据，但抽取之后这一万条数据就变成了一条数据，极大的减少了数据查询两。 减少查询核心订单表的次数，缓解了订单表的压力。 实现方案较为简单，只需引入mq消息去同步修改抽取表的数据即可。    方案劣势    订单表数据量大的问题没有解决，对于一些必须查询订单表的情况可能不大友好。 引入mq这种消息就面临着这种数据的不一致问题（运营允许当天数据可以不准确，所以对我们影响不大）   3.</description>
    </item>
    
    <item>
      <title>递归构建树结构(泛型)</title>
      <link>https://fruitkang.github.io/tools/%E9%80%92%E5%BD%92%E6%9E%84%E5%BB%BA%E6%A0%91%E7%BB%93%E6%9E%84%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Mon, 20 Jun 2022 22:12:50 +0800</pubDate>
      
      <guid>https://fruitkang.github.io/tools/%E9%80%92%E5%BD%92%E6%9E%84%E5%BB%BA%E6%A0%91%E7%BB%93%E6%9E%84%E6%B3%9B%E5%9E%8B/</guid>
      <description>/** * @author gzk * @description: 树的工具类 * @since 2022/6/7 */ public class TreeUtil { /** * * Function2&amp;lt;W, List&amp;lt;W&amp;gt;, List&amp;lt;W&amp;gt;&amp;gt; findChildrenFunction，第一个参数为头结点，第二个参数为所有节点，第三个为返回值，子节点 * 组装树 * * @param headNodes 头节点 * @param allNodes 所有节点 * @param findChildrenFunction 寻找子节点的方法， * @param &amp;lt;W&amp;gt; 节点泛型 */ public static &amp;lt;W&amp;gt; List&amp;lt;TreeNode&amp;lt;W&amp;gt;&amp;gt; packTree(List&amp;lt;W&amp;gt; headNodes, List&amp;lt;W&amp;gt; allNodes, Function2&amp;lt;W, List&amp;lt;W&amp;gt;, List&amp;lt;W&amp;gt;&amp;gt; findChildrenFunction) { //参数校验 if (CollectionUtil.isEmpty(headNodes)) { return Collections.emptyList(); } if (CollectionUtil.isEmpty(allNodes) || findChildrenFunction == null) { return headNodes.</description>
    </item>
    
  </channel>
</rss>